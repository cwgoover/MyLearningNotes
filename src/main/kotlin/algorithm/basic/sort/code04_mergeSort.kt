package algorithm.basic.sort

/**
 * å½’å¹¶æ’åºï¼Œæ—¶é—´å¤æ‚åº¦O(N*logN), é¢å¤–ç©ºé—´å¤æ‚åº¦O(N) â€”â€” æœ€å¤šåªç”¨å‡†å¤‡Nçš„é¢å¤–ç©ºé—´å°±è¶³å¤Ÿ
 *
 * æ•´ä½“å°±æ˜¯ä¸€ä¸ªç®€å•é€’å½’ï¼Œæ•°ç»„ä»ä¸­ç‚¹åˆ†ä¸¤éƒ¨åˆ†ï¼Œå·¦è¾¹æ’å¥½åºã€å³è¾¹æ’å¥½åºï¼Œç„¶åmergeä¸¤è¾¹çš„åºåˆ—ï¼Œè®©æ•´ä½“æœ‰åºã€‚
 * mergeçš„æ–¹æ³•æ˜¯ï¼šä¸¤ä¸ªæ•°ç»„éƒ½å„ä»ç¬¬ä¸€ä½å¼€å§‹è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœå·¦ä¾§æ•°ç»„çš„æ•°å€¼å°äºç­‰äºå³ä¾§çš„ï¼Œcopyå·¦ä¾§çš„å€¼åˆ°æ–°åˆ›å»ºçš„æ•°å€¼ï¼›
 *   å¦‚æœå·¦ä¾§å€¼å¤§äºå³ä¾§çš„ï¼Œcopyå³ä¾§çš„å€¼åˆ°æ–°æ•°ç»„ (è°å°copyè°)ï¼›copyç»“æŸåç§»åŠ¨ä¸‹æ ‡åˆ°ä¸‹ä¸€ä½è¿›è¡Œæ¯”è¾ƒï¼›ç›´åˆ°æŸä¸€è¾¹å…¨éƒ¨
 *   copyå®Œåï¼Œå°†å‰©ä¸‹æ•°ç»„ä¸­çš„å…ƒç´ å…¨éƒ¨copyåˆ°æ–°æ•°ç»„ï¼Œç»“æŸmerge
 *
 * è¿™é‡Œçš„æ ¸å¿ƒæ˜¯åœ¨mergeæ—¶å·²ç»ç¡®å®šäº†å·¦å³ä¸¤è¾¹çš„æ•°ç»„éƒ½æ˜¯æœ‰åºçš„ï¼Œé‚£ä¹ˆåœ¨éå†å¹¶mergeçš„æ—¶å€™å°±åªè€ƒè™‘å°†ä¸¤ä¸ªæ•°ç»„çš„æ•°mergeå¹¶æ’åº
 * åˆ°å¤–éƒ¨æ•°ç»„ä¸­ï¼Œè€Œä¸è€ƒè™‘å·¦å³ä¸¤è¾¹æ•°ç»„å†…çš„æ’åºé—®é¢˜ï¼›å¹¶ä¸”ä¸€æ—¦ä¸€è¾¹æ•°ç»„éå†å®Œæˆåå°±å¯ä»¥é€€å‡ºéå†ï¼Œå°†å¦å¤–ä¸€è¾¹å‰©ä¸‹çš„å…ƒç´ ç›´æ¥å¤åˆ¶
 * åˆ°å¤–éƒ¨æ•°ç»„ä¸­å°±å¯ä»¥äº†ã€‚
 * å› ä¸ºè¿™é‡Œç›¸å½“äºåˆ©ç”¨äº†ä¹‹å‰æ’åºçš„ç»“æœ(mergeæ—¶ç¡®å®šå·¦å³ä¸¤è¾¹çš„æ•°ç»„éƒ½æ˜¯æœ‰åºçš„)ï¼Œåœ¨mergeæ’åºä¸­èŠ‚çœäº†éƒ¨åˆ†éå†ã€‚æ‰€ä»¥å½’å¹¶æ’åºçš„
 * æ—¶é—´å¤æ‚åº¦è¦ä¼˜äºé€‰æ‹©æ’åºï¼Œå†’æ³¡æ’åºå’Œæ’å…¥æ’åºï¼Œè¿™ä¸‰ç§æ’åºæ¯æ¬¡æ’åºéƒ½æ˜¯ç‹¬ç«‹çš„ï¼Œå®Œå…¨æ²¡æœ‰åˆ©ç”¨ä¹‹å‰çš„æ’åºç»“æœã€‚è‡³äºå…¶ä¸ºO(N*logN)
 * æ˜¯å› ä¸ºå®ƒåˆ©ç”¨äº†é€’å½’è¡Œä¸ºï¼Œå¹¶ä¸”ç¬¦åˆmasterå…¬å¼çš„æ¡ä»¶æ¥æ±‚è§£æ—¶é—´å¤æ‚åº¦ï¼Œæœ€åçš„è®¡ç®—ç»“æœå°±æ˜¯O(N*logN)ã€‚
 * å…·ä½“çš„è§£é‡Šå¯ä»¥å‚è€ƒæˆ‘çš„ç¬”è®°(é»„çš®çš„ç¬”è®°æœ¬ğŸ“’)
 *
 * è®©å…¶æ•´ä½“æœ‰åºçš„è¿‡ç¨‹é‡Œç”¨äº†å¤–æ’åºæ–¹æ³• (å¤–æ’åº: ä¸¤æŒ‡é’ˆæ’åºåçš„ä¸œè¥¿copyåˆ°å¤–éƒ¨æ•°ç»„ä¸­ç„¶åå†copyå›å»)
 *
 * åˆ©ç”¨masterå…¬å¼æ¥æ±‚è§£æ—¶é—´å¤æ‚åº¦:
 * T(N) = 2 * T(N / 2) + O(N) => a = 2, b = 2, d = 1
 *  => log(b, a) = d => O(N * logN)
 *
 * Created by i352072(erica.cao@sap.com) on 03/29/2022
 */
object code04_mergeSort {
    
    fun mergeSort(arr: ArrayList<Int>?) {
        if (arr == null || arr.size < 2) {
            return
        }
        process(arr, 0, arr.size - 1)
    }
    
    private fun process(arr: ArrayList<Int>, start: Int, end: Int) {
        if (start == end) return    // ç»“æŸæ¡ä»¶, åˆ°å¶èŠ‚ç‚¹äº†
    
//        val mid = start + (end - start) shr 1 // Error: æœ€å³è¾¹å¿…é¡»å¸¦æ‹¬å·ï¼Œä½è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§ä½äºåŠ å‡è¿ç®—ç¬¦
        val mid = start + ((end - start) shr 1)
        process(arr, start, mid)
        process(arr, mid + 1, end)
        merge(arr, start, mid, end) // Note: çœŸå®æ’åºéƒ¨åˆ†
    }
    
    private fun merge(arr: ArrayList<Int>, start: Int, mid: Int, end: Int) {
//        val newArray = ArrayList<Int>(arr.size)   // Error: arrçš„é•¿åº¦ä¸€ç›´ä¸å˜ä¸èƒ½ç›´æ¥ç”¨ï¼Œæˆ‘ä»¬éœ€è¦çš„æ˜¯mergeéƒ¨åˆ†çš„æ•°ç»„é•¿åº¦
        val newArray = ArrayList<Int>(end - start + 1)
        var lp = start
        var rp = mid + 1
        // è¿›è¡Œåˆå¹¶
        while (lp <= mid && rp <= end) {
//            newArray.add(if (arr[lp] <= arr[rp]) arr[lp++] else arr[rp++])
            if (arr[lp] <= arr[rp]) {
                newArray.add(arr[lp])
                lp++
            } else {
                newArray.add(arr[rp])
                rp++
            }
        }
        // Error: å°†å‰©ä½™çš„å…ƒç´ copyåˆ°æ–°æ•°ç»„
        while (lp <= mid) {
            newArray.add(arr[lp++])
        }
        while (rp <= end) {
            newArray.add(arr[rp++])
        }
        // copyå›åŸæ•°ç»„
//        arr.addAll(0, newArray)
//        arr.addAll(start, newArray) // Error: è¿™ä¸ªæ–¹æ³•æ˜¯åœ¨startçš„ä½ç½®æ’å…¥æ–°æ•°ç»„å…ƒç´ ï¼Œä¼šå¯¼è‡´åŸæ•°ç»„å˜é•¿ï¼›æœ€åé€ æˆå †æ ˆæº¢å‡º: java.lang.StackOverflowError
        for (i in newArray.indices) {
            arr[start + i] = newArray[i]
        }
    }
}