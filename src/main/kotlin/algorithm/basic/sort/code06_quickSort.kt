package algorithm.basic.sort

import algorithm.basic.sort.code01_selectionSort.swap
import kotlin.random.Random

/**
 * 快速排序，时间复杂度O(N^2) —— 虽然快排是用递归方式实现，应该类似于归并排序的O(N*logN)。那为什么却是O(N^2)呢？
 *  因为总能找到最坏的情况，类似数组[1, 2, 3, 4, 5, 6, 7, 8, 9], 整个范围上拿9做划分，只搞定了9的位置在最右边，9的右侧
 *  没有比它更大的数了；然后从9的左侧继续排序，拿8做划分，与9的情况类似又是只能搞定8的位置；以此类推下去。
 *  每次划分的过程就是partition的过程，而这里每一次partition只搞定了一个数。搞定9时partition过了9个数；搞定8时
 *  partition过了8个数，搞定7时partition过了7个数，以此类推下去就是等差数列，就是O(N^2)
 * 所以快速排序1.0和快速排序2.0版本在面对最差的情况时，时间复杂度都是O(N^2)
 *
 * 注：快速排序借鉴了荷兰旗问题的解法，可先回顾"code05_netherLandsFlag"了解具体思路
 *
 *  快速排序-1.0 —— 时间复杂度O(N^2)
 *   思路：在整个数组中，拿最后一位的数做划分值，类似于荷兰旗问题里的num；
 *      1) 对数组中除了最后位置的其他值进行划分，做到: 小于等于num的放在数组左边，大于num的放在数组右边
 *      2) 然后将用于划分的数(最后一位的数)跟大于区域的第一个数进行交换；这样做相当于扩充小于等于区域的数，并且区域最后
 *          一位一定是等于该划分的数；区域外的都是大于该数的数；这样做后，相当于确定了两个区间，一个数的位置；这个数
 *          就是刚交换后的划分的数(位置：大于区域的第一个数的位置)，因为这个数现在所在的位置一定是排序后它该在的位置，它的
 *          左边都是小于或等于它的数，它的右边都是大于它的数。至于两个区间，就是这个数的左侧的小于等于区域，和数右侧的
 *          大于区域
 *      3) 然后对左右两个区域分别重复上面的行为，即继续选择区域内最后一位作为划分值，对它之前的数进行划分，划分后得到
 *          另外两个区域和一个数的位置。继续采用递归方式，对另外两个区域继续重复这种行为(选择区域内最后一位作为划分值进行划分)
 *      4) 一直递归到区域内的数本身有序为止
 *
 *   核心是在一个范围上总拿范围内最后一个数做划分，然后把这个最后一个数放到大于区域的第一个数(做交换，也即小于等于区域的最后)，
 *  然后确定这个数的位置，并且分别递归该数左侧的小于等于区域和右侧大于区域；这样每次都能排好一个数，所以总有整体都有序的时候！
 *
 *  快速排序-2.0 —— 时间复杂度O(N^2)
 *   思路：荷兰国旗问题 —— 在整个数组中，拿最后一位的数做划分值(类似num)
 *      1) 让除最后一位的所有数做到小于num的在左边，中间是等于num的区域，大于num的在右边
 *      2) 将末尾的num和大于区域的第一个数交换；这样等于num的所有数都靠在一起了，整个数组被分成了三个区域，小于、等于、大于
 *          整个等于区域的位置就全部确定下来，不需要再动了。
 *      3) 然后只需要分别在小于区域和大于区域继续做递归；因为每一次递归可以确认一批等于区域的数，所以总有全部有序的时候
 *      4) 一直递归到区域内的数本身有序为止
 *
 *   核心就是荷兰国旗问题的解法，比1.0版本强化的地方是在于在一次递归过程中可以确认一批等于区域的数的位置，所以稍快一些
 *
 *  快速排序-3.0 —— 优化快速排序2.0版本
 *   思路：快排2.0版本的问题就是它的最差情况会导致时间复杂度变大。而最差情况的原因就是划分值打的很偏，一次partition时仅能确认一个值而已。
 *      好的情况是划分值几乎打在中间的位置上，这样左侧和右侧递归规模差不多，根据Master公式可得T(N) = 2T(N/2) + O(N),
 *      这里的O(N)就是partition过程(做一次循环)，可得时间复杂度为O(N*logN); 而划分值打偏就会逐渐退化成O(N^2)的算法。
 *      因为总是拿数组最后一个数做划分，所以差情况没有办法避免；
 *    所以3.0版本呢，在数组R~L的范围内做划分，不会再用最后一位做划分了:
 *      而是随机选择一个数！用随机选择的这个数跟最后一位做交换，然后再拿最后位置的这个数做划分。
 *      这样做的原因是通过随机选择的方式，就可以让最后位做划分的好情况和坏情况概率出现，并且是等概率出现。根据概率论里，假设
 *      在划分时有N中情况，那么每种情况出现的概率是1/N, 将所有情况做概率累加，再求数学上的长期期望，得到的是O(N*logN)，
 *      就是这个算法的时间复杂度
 *  核心: 跟快排2.0版本比，3.0版本只多做了一件事，就是随机选择一个数做划分，就保证了时间复杂度为O(N*logN)
 *
 * Created by i352072(erica.cao@sap.com) on 04/07/2022
 */
object code06_quickSort {

    fun quickSort(arr: ArrayList<Int>?) {
        if (arr == null || arr.size < 2) {
            return
        }
        quickSort(arr, 0, arr.size - 1)
    }
    
    // arr[L..R] 排好序
    private fun quickSort(arr: ArrayList<Int>, L: Int, R: Int) {
        if (L < R) {    // 递归结束条件: L >= R
            // 1. 从 L ~ R-1 间选出一个随机数和此轮最后一位的数R交换，以此产生等概率随机划分
            val randomIndex = Random.nextInt(L, R)
            swap(arr, randomIndex, R)
            // 做此轮的partition划分，做到小于原R位所在值的在左边，中间是等于原R位所在值的区域，大于原R位所在值的在右边
            // partition返回两个值用数组表示，第一个是等于区间的第一个数的位置；第二个是等于区间的最后一个数所在的位置
            val margins = partition(arr, L, R)
            // 分别在小于区域和大于区域继续做递归
            quickSort(arr, L, margins[0] - 1)   // < 区
            quickSort(arr, margins[1] + 1, R)   // > 区
        }
    }
    
    private fun partition(arr: ArrayList<Int>, L: Int, R: Int): ArrayList<Int> {
        var i = L
        var leftMargin = L - 1  // < 区域的右边界: 起始位置在数组的最左端(初始位置的左面)
        var rightMargin = R // > 区域的左边界: 因为是除最后一位外的数组的最右端(末尾位置的右面)，所以 R - 1 + 1 = R
        while (i < rightMargin) {
            if (arr[i] < arr[R]) {
                // 把当前数arr[i] 和小于区域的下一个数进行交换；然后将小于区域往右扩一个位置，当前数跳下一个(i++)
                swap(arr, i, leftMargin + 1)
                leftMargin++
                i++
//                swap(arr, i++, ++leftMargin)  // 上面三句等于这一句
            } else if (arr[i] == arr[R]) {
                // 直接将i跳下一个(i++)
                i++
            } else {
                // 把当前数arr[i] 和大于区域的前一个数进行交换；然后将大于区域往左扩一个位置，当前数位置不变(i不变)
                swap(arr, i, rightMargin - 1)
                rightMargin--
//                swap(arr, i, --rightMargin)  // 上面两句等于这一句
            }
        }
        // 将末尾R位所在值和大于区域的第一个数交换, 让等于原R位所在值的所有数都靠在一起
        swap(arr, R, rightMargin++)     // 交换后，大于区域边界应该向右移一位
        // 返回等于区间的第一个数和最后一个数的坐标
        return arrayListOf(leftMargin + 1, rightMargin - 1)
    }
    
}